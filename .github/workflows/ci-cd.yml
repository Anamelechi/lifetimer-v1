name: CI/CD

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  workflow_dispatch:

concurrency:
  group: ci-cd-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read

env:
  NODE_VERSION: '20.x'
  WORKING_DIR: life-timer

jobs:
  ci:
    name: Lint and build
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ${{ env.WORKING_DIR }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm
          cache-dependency-path: ${{ env.WORKING_DIR }}/package-lock.json

      - name: Install dependencies
        run: npm ci --no-audit --no-fund

      - name: Lint
        run: npm run lint --if-present

      - name: Build
        run: npm run build

  deploy:
    name: Deploy to server (rebuild on host)
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    needs: ci
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Create app bundle (source only)
        run: |
          tar \
            --exclude='.next' \
            --exclude='node_modules' \
            --exclude='.git' \
            --exclude='.github' \
            -czf life-timer-app.tar.gz -C life-timer .

      - name: Copy app bundle to server
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_KEY }}
          source: "life-timer-app.tar.gz"
          target: "${{ secrets.DEPLOY_PATH }}/tmp"

      - name: Remote deploy (blue/green, zero-downtime)
        uses: appleboy/ssh-action@v1.2.0
        env:
          COMPOSE_FILE: ${{ secrets.COMPOSE_FILE }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
          APP_SUBDIR: ${{ secrets.APP_SUBDIR }}
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_KEY }}
          envs: COMPOSE_FILE,DEPLOY_PATH,APP_SUBDIR
          script: |
            set -eu
            if [ -z "${DEPLOY_PATH}" ]; then
              echo "DEPLOY_PATH secret is not set" >&2
              exit 1
            fi
            if [ ! -d "${DEPLOY_PATH}" ]; then
              echo "DEPLOY_PATH does not exist: ${DEPLOY_PATH}" >&2
              exit 1
            fi
            cd "${DEPLOY_PATH}"
            echo "Working dir: $(pwd)"
            echo "Listing top-level files:"
            ls -la

            # Select docker compose CLI (Compose V2 preferred)
            if docker compose version >/dev/null 2>&1; then
              DCMD="docker compose"
            elif command -v docker-compose >/dev/null 2>&1; then
              DCMD="docker-compose"
            else
              echo "docker compose not available on server" >&2
              exit 1
            fi

            # Place app source into build context subdirectory (default: app)
            APP_DIR_NAME="${APP_SUBDIR:-app}"
            APP_DIR_PATH="${DEPLOY_PATH}/${APP_DIR_NAME}"
            mkdir -p "${APP_DIR_PATH}"
            echo "Refreshing app sources in: ${APP_DIR_PATH}"
            rm -rf "${APP_DIR_PATH:?}"/*
            tar -xzf "${DEPLOY_PATH}/tmp/life-timer-app.tar.gz" -C "${APP_DIR_PATH}"
            rm -f "${DEPLOY_PATH}/tmp/life-timer-app.tar.gz" || true

            # Choose compose file to use
            CHOICES=(
              "${COMPOSE_FILE:-}"
              "${DEPLOY_PATH}/docker-compose.yml"
              "${DEPLOY_PATH}/docker-compose.prod.yml"
              "${DEPLOY_PATH}/life-timer/docker-compose.prod.yml"
            )
            COMPOSE_PATH=""
            for c in "${CHOICES[@]}"; do
              if [ -n "$c" ] && [ -f "$c" ]; then COMPOSE_PATH="$c"; break; fi
            done
            if [ -z "$COMPOSE_PATH" ]; then
              echo "No compose file found. Checked: ${CHOICES[*]}" >&2
              exit 1
            fi
            COMPOSE_DIR=$(dirname "$COMPOSE_PATH")
            COMPOSE_BASE=$(basename "$COMPOSE_PATH")
            echo "Compose directory: $COMPOSE_DIR"
            echo "Compose file: $COMPOSE_BASE"
            cd "$COMPOSE_DIR"

            # Resolve env file in compose directory per docs
            if [ -f ".env" ]; then
              ENV_FILE=".env"
            elif [ -f "../.env" ]; then
              ENV_FILE="../.env"
            elif [ -f "config/.env" ]; then
              ENV_FILE="config/.env"
            else
              ENV_FILE="/tmp/empty.env"; : > "$ENV_FILE"
            fi
            if [ ! -f "$ENV_FILE" ]; then
              echo "Resolved env path is not a file ($ENV_FILE). Using empty env instead." >&2
              ENV_FILE="/tmp/empty.env"; : > "$ENV_FILE"
            fi
            echo "Using env file: $ENV_FILE"; ls -ld "$ENV_FILE"

            # Blue/Green deploy with zero downtime
            # Strategy:
            # 1) Run new stack under alternate project on an alternate port (3001 or 3002) using an override file.
            # 2) Wait for container healthcheck to be healthy.
            # 3) Atomically switch host traffic on port 3000 to the new port via iptables REDIRECT.
            # 4) Retire old stack.

            ACTIVE_PORT_FILE="${DEPLOY_PATH}/.active_port"
            if [ -f "$ACTIVE_PORT_FILE" ]; then
              ACTIVE_PORT=$(cat "$ACTIVE_PORT_FILE" || true)
            else
              ACTIVE_PORT="" # unknown first run
            fi
            if [ "$ACTIVE_PORT" != "3001" ] && [ "$ACTIVE_PORT" != "3002" ]; then
              # Initialize to 3001 on first run
              ACTIVE_PORT=3001
              echo "$ACTIVE_PORT" > "$ACTIVE_PORT_FILE"
            fi
            if [ "$ACTIVE_PORT" = "3001" ]; then NEW_PORT=3002; else NEW_PORT=3001; fi

            NEW_PROJECT="life-timer-${NEW_PORT}"
            OLD_PROJECT="life-timer-${ACTIVE_PORT}"

            # Detect primary service name from compose config
            SERVICES=$(${DCMD} -f "$COMPOSE_BASE" --env-file "$ENV_FILE" config --services)
            if echo "$SERVICES" | grep -q "^web$"; then
              SERVICE="web"
            else
              SERVICE=$(echo "$SERVICES" | head -n1)
            fi
            if [ -z "$SERVICE" ]; then
              echo "Could not detect a service name from compose config" >&2
              exit 1
            fi

            OVERRIDE_FILE="/tmp/life-timer-override-${NEW_PORT}.yml"
            echo "Creating override ${OVERRIDE_FILE} mapping ${NEW_PORT}->3000"
            cat > "$OVERRIDE_FILE" <<EOF
            services:
              ${SERVICE}:
                ports:
                  - "${NEW_PORT}:3000"
            EOF

            echo "Building and starting new stack: ${NEW_PROJECT} on port ${NEW_PORT}"
            set +e
            ${DCMD} -p "$NEW_PROJECT" -f "$COMPOSE_BASE" -f "$OVERRIDE_FILE" --env-file "$ENV_FILE" build --pull --no-cache
            BUILD_RC=$?
            set -e
            if [ $BUILD_RC -ne 0 ]; then
              echo "Primary build failed; attempting fallback by injecting temporary build context override..."
              OVERRIDE_BUILD="/tmp/life-timer-override-build.yml"
              cat > "$OVERRIDE_BUILD" <<EOF
              services:
                ${SERVICE}:
                  build:
                    context: "${DEPLOY_PATH}"
                    dockerfile: "Dockerfile"
              EOF
              ${DCMD} -p "$NEW_PROJECT" -f "$COMPOSE_BASE" -f "$OVERRIDE_BUILD" -f "$OVERRIDE_FILE" --env-file "$ENV_FILE" build --pull --no-cache
              USE_BUILD_OVERRIDE=1
            else
              USE_BUILD_OVERRIDE=0
            fi
            if [ "$USE_BUILD_OVERRIDE" = "1" ]; then
              ${DCMD} -p "$NEW_PROJECT" -f "$COMPOSE_BASE" -f "$OVERRIDE_BUILD" -f "$OVERRIDE_FILE" --env-file "$ENV_FILE" up -d
            else
              ${DCMD} -p "$NEW_PROJECT" -f "$COMPOSE_BASE" -f "$OVERRIDE_FILE" --env-file "$ENV_FILE" up -d
            fi

            # Wait for health (Compose service name: web)
            NEW_CID=$(${DCMD} -p "$NEW_PROJECT" ps -q "$SERVICE")
            if [ -z "$NEW_CID" ]; then echo "Failed to get container ID for new web" >&2; exit 1; fi
            echo "Waiting for new container ($NEW_CID) to become healthy..."
            ATTEMPTS=40
            SLEEP=3
            OK=0
            for i in $(seq 1 $ATTEMPTS); do
              STATUS=$(docker inspect -f '{{ if .State.Health }}{{ .State.Health.Status }}{{ else }}none{{ end }}' "$NEW_CID" 2>/dev/null || echo "unknown")
              echo "Health attempt $i: $STATUS"
              if [ "$STATUS" = "healthy" ]; then OK=1; break; fi
              # Fallback: probe HTTP on the new published port
              if command -v curl >/dev/null 2>&1; then
                if curl -fsS --max-time 2 "http://127.0.0.1:${NEW_PORT}/" >/dev/null; then
                  OK=1; break;
                fi
              elif command -v wget >/dev/null 2>&1; then
                if wget -q -T 2 -O - "http://127.0.0.1:${NEW_PORT}/" >/dev/null; then
                  OK=1; break;
                fi
              fi
              sleep $SLEEP
            done
            if [ "$OK" != "1" ]; then
              echo "New container did not become healthy in time" >&2
              ${DCMD} -p "$NEW_PROJECT" logs --no-log-prefix "$SERVICE" || true
              exit 1
            fi

            # Determine sudo availability for iptables
            if command -v sudo >/dev/null 2>&1 && sudo -n true >/dev/null 2>&1; then SUDO="sudo -n"; else SUDO=""; fi

            # Install/update LT_REDIRECT chain for port 3000
            # Compose docs: running multiple projects is supported via -p. We avoid port conflicts by alternate external port.
            # iptables REDIRECT per Netfilter NAT docs: https://ipset.netfilter.org/iptables-extensions.man.html#lbCH
            $SUDO iptables -t nat -N LT_REDIRECT 2>/dev/null || true
            $SUDO iptables -t nat -F LT_REDIRECT || true
            $SUDO iptables -t nat -C PREROUTING -p tcp --dport 3000 -j LT_REDIRECT 2>/dev/null || \
              $SUDO iptables -t nat -I PREROUTING 1 -p tcp --dport 3000 -j LT_REDIRECT
            # Redirect 3000 -> NEW_PORT
            $SUDO iptables -t nat -A LT_REDIRECT -p tcp --dport 3000 -j REDIRECT --to-ports ${NEW_PORT}

            # Optionally mirror for local-origin traffic (OUTPUT), useful if local tools hit :3000
            $SUDO iptables -t nat -N LT_REDIRECT_OUT 2>/dev/null || true
            $SUDO iptables -t nat -F LT_REDIRECT_OUT || true
            $SUDO iptables -t nat -C OUTPUT -p tcp --dport 3000 -j LT_REDIRECT_OUT 2>/dev/null || \
              $SUDO iptables -t nat -I OUTPUT 1 -p tcp --dport 3000 -j LT_REDIRECT_OUT
            $SUDO iptables -t nat -A LT_REDIRECT_OUT -p tcp --dport 3000 -j REDIRECT --to-ports ${NEW_PORT}

            # Mark NEW as active and retire OLD
            echo "${NEW_PORT}" > "$ACTIVE_PORT_FILE"
            echo "Traffic switched to port ${NEW_PORT}. Retiring old project: ${OLD_PROJECT}"
            # Stop and remove old project if it exists
            if ${DCMD} -p "$OLD_PROJECT" ps >/dev/null 2>&1; then
              ${DCMD} -p "$OLD_PROJECT" down --remove-orphans || true
            fi

            echo "Currently running containers:"
            docker ps --format '{{.Names}}\t{{.Image}}\t{{.Status}}\t{{.Ports}}'

            # Cleanup temporary files
            rm -f "$OVERRIDE_FILE" "$OVERRIDE_BUILD" || true
