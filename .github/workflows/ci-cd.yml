name: CI/CD

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  workflow_dispatch:

concurrency:
  group: ci-cd-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  packages: write

env:
  NODE_VERSION: '20.x'
  WORKING_DIR: life-timer
  REGISTRY: ghcr.io
  IMAGE_NAME: ghcr.io/${{ github.repository_owner }}/life-timer

jobs:
  ci:
    name: Lint, build, and push image
    outputs:
      image: ${{ steps.lower.outputs.image }}
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ${{ env.WORKING_DIR }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Derive lowercase image name
        id: lower
        run: |
          OWNER_LOWER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          echo "owner_lower=$OWNER_LOWER" >> $GITHUB_OUTPUT
          echo "image=ghcr.io/${OWNER_LOWER}/life-timer" >> $GITHUB_OUTPUT

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm
          cache-dependency-path: ${{ env.WORKING_DIR }}/package-lock.json

      - name: Install dependencies
        run: npm ci --no-audit --no-fund

      - name: Lint
        run: npm run lint --if-present

      - name: Build
        run: npm run build

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push image
        uses: docker/build-push-action@v6
        with:
          context: ${{ env.WORKING_DIR }}
          file: ${{ env.WORKING_DIR }}/Dockerfile
          push: true
          tags: |
            ${{ steps.lower.outputs.image }}:${{ github.sha }}
            ${{ steps.lower.outputs.image }}:latest

  deploy:
    name: Deploy to server
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    needs: ci
    runs-on: ubuntu-latest
    steps:
      - name: Remote deploy
        uses: appleboy/ssh-action@v1.2.0
        env:
          COMPOSE_FILE: ${{ secrets.COMPOSE_FILE }}
          REGISTRY: ${{ env.REGISTRY }}
          IMAGE_NAME: ${{ needs.ci.outputs.image }}
          IMAGE_TAG: ${{ github.sha }}
          GHCR_USERNAME: ${{ github.actor }}
          GHCR_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_KEY }}
          envs: COMPOSE_FILE,REGISTRY,IMAGE_NAME,IMAGE_TAG,GHCR_USERNAME,GHCR_TOKEN,DEPLOY_PATH
          script: |
            set -eu
            if [ -z "${DEPLOY_PATH}" ]; then
              echo "DEPLOY_PATH secret is not set" >&2
              exit 1
            fi
            if [ ! -d "${DEPLOY_PATH}" ]; then
              echo "DEPLOY_PATH does not exist: ${DEPLOY_PATH}" >&2
              exit 1
            fi
            cd "${DEPLOY_PATH}"
            echo "Working dir: $(pwd)"
            echo "Listing top-level files:"
            ls -la

            echo "Using docker compose (ignoring deploy.sh per CI config)"
            # Select docker compose CLI
            if docker compose version >/dev/null 2>&1; then
              DCMD="docker compose"
            elif command -v docker-compose >/dev/null 2>&1; then
              DCMD="docker-compose"
            else
              echo "docker compose not available on server" >&2
              exit 1
            fi

            # Choose compose file to use
            CHOICES=(
              "${COMPOSE_FILE:-}"
              "${DEPLOY_PATH}/docker-compose.yml"
              "${DEPLOY_PATH}/docker-compose.prod.yml"
              "${DEPLOY_PATH}/life-timer/docker-compose.prod.yml"
            )
            COMPOSE_PATH=""
            for c in "${CHOICES[@]}"; do
              if [ -n "$c" ] && [ -f "$c" ]; then COMPOSE_PATH="$c"; break; fi
            done
            if [ -z "$COMPOSE_PATH" ]; then
              echo "No compose file found. Checked: ${CHOICES[*]}" >&2
              exit 1
            fi
            COMPOSE_DIR=$(dirname "$COMPOSE_PATH")
            COMPOSE_BASE=$(basename "$COMPOSE_PATH")
            echo "Compose directory: $COMPOSE_DIR"
            echo "Compose file: $COMPOSE_BASE"
            cd "$COMPOSE_DIR"

            # Resolve env file in compose directory per docs
            if [ -f ".env" ]; then
              ENV_FILE=".env"
            elif [ -f "../.env" ]; then
              ENV_FILE="../.env"
            elif [ -f "config/.env" ]; then
              ENV_FILE="config/.env"
            else
              ENV_FILE="/tmp/empty.env"; : > "$ENV_FILE"
            fi
            if [ ! -f "$ENV_FILE" ]; then
              echo "Resolved env path is not a file ($ENV_FILE). Using empty env instead." >&2
              ENV_FILE="/tmp/empty.env"; : > "$ENV_FILE"
            fi
            echo "Using env file: $ENV_FILE"; ls -ld "$ENV_FILE"

            # Login to GHCR to pull the image
            echo "$GHCR_TOKEN" | docker login "$REGISTRY" -u "$GHCR_USERNAME" --password-stdin

            # Export image info for compose
            export IMAGE_REPO="$IMAGE_NAME"
            export IMAGE_TAG="$IMAGE_TAG"

            # Pull and restart services with explicit env file and chosen compose file
            ${DCMD} -f "$COMPOSE_BASE" --env-file "$ENV_FILE" pull || true
            ${DCMD} -f "$COMPOSE_BASE" --env-file "$ENV_FILE" up -d --force-recreate
            docker system prune -f || true
