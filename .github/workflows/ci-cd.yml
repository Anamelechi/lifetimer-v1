name: CI/CD

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  workflow_dispatch:

concurrency:
  group: ci-cd-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read

env:
  NODE_VERSION: '20.x'
  WORKING_DIR: life-timer

jobs:
  ci:
    name: Lint and build
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ${{ env.WORKING_DIR }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm
          cache-dependency-path: ${{ env.WORKING_DIR }}/package-lock.json

      - name: Install dependencies
        run: npm ci --no-audit --no-fund

      - name: Lint
        run: npm run lint --if-present

      - name: Build
        run: npm run build

      - name: Upload build artifact (PRs only)
        if: github.event_name == 'pull_request'
        uses: actions/upload-artifact@v4
        with:
          name: next-build
          path: |
            life-timer/.next
            life-timer/public
          retention-days: 7

  deploy:
    name: Deploy to server
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    needs: ci
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Create deployment bundle
        run: |
          tar --exclude='.next' --exclude='node_modules' -czf life-timer.tar.gz -C life-timer .

      - name: Copy bundle to server
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_KEY }}
          source: "life-timer.tar.gz"
          target: "${{ secrets.DEPLOY_PATH }}/tmp"

      - name: Remote deploy
        uses: appleboy/ssh-action@v1.2.0
        env:
          COMPOSE_FILE: ${{ secrets.COMPOSE_FILE }}
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_KEY }}
          envs: COMPOSE_FILE
          script: |
            set -eu
            DEPLOY_PATH="${{ secrets.DEPLOY_PATH }}"
            if [ -z "${DEPLOY_PATH}" ]; then
              echo "DEPLOY_PATH secret is not set" >&2
              exit 1
            fi
            if [ ! -d "${DEPLOY_PATH}" ]; then
              echo "DEPLOY_PATH does not exist: ${DEPLOY_PATH}" >&2
              exit 1
            fi
            cd "${DEPLOY_PATH}"
            echo "Working dir: $(pwd)"
            mkdir -p tmp app
            # Extract the application into the app/ folder
            tar -xzf tmp/life-timer.tar.gz -C app
            rm -f tmp/life-timer.tar.gz

            # If a deploy.sh is present at DEPLOY_PATH, prefer it
            if [ -x "./deploy.sh" ]; then
              echo "Running deploy.sh..."
              bash ./deploy.sh
            else
              echo "deploy.sh not found, using docker compose"
              # Select docker compose CLI
              if docker compose version >/dev/null 2>&1; then
                DCMD="docker compose"
              elif command -v docker-compose >/dev/null 2>&1; then
                DCMD="docker-compose"
              else
                echo "docker compose not available on server" >&2
                exit 1
              fi

              # Choose compose file: priority COMPOSE_FILE secret, else common defaults
              COMPOSE_ARGS=""
              if [ -n "${COMPOSE_FILE:-}" ] && [ -f "${COMPOSE_FILE}" ]; then
                echo "Using compose file: ${COMPOSE_FILE}"
                COMPOSE_ARGS="-f ${COMPOSE_FILE}"
              elif [ -f "docker-compose.yml" ]; then
                echo "Using docker-compose.yml in ${DEPLOY_PATH}"
              elif [ -f "docker-compose.apache.yml" ]; then
                echo "Using docker-compose.apache.yml in ${DEPLOY_PATH}"
                COMPOSE_ARGS="-f docker-compose.apache.yml"
              else
                echo "No compose file found in ${DEPLOY_PATH}. Provide COMPOSE_FILE secret or add a compose file." >&2
                exit 1
              fi

              # Resolve env file: handle case where .env is a directory (compose would error)
              ENV_FILE=""
              if [ -f ".env" ]; then
                ENV_FILE=".env"
              elif [ -f "config/.env" ]; then
                ENV_FILE="config/.env"
              else
                # Create a temporary empty env file to avoid compose trying to read a directory named .env
                ENV_FILE="/tmp/empty.env"
                : > "$ENV_FILE"
              fi

              # Build and restart services with explicit env file
              ${DCMD} ${COMPOSE_ARGS} --env-file "$ENV_FILE" pull || true
              ${DCMD} ${COMPOSE_ARGS} --env-file "$ENV_FILE" build
              ${DCMD} ${COMPOSE_ARGS} --env-file "$ENV_FILE" up -d
            fi
            docker system prune -f || true
